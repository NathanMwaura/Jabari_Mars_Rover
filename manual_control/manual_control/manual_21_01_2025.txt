#!/usr/bin/env python3
"""
JABARI MARS ROVER - Manual Control Node (Merged, PCA9685 /vector3_cmd)

This merges:
- Refined Manual Control Node (params, e-stop, timeout, status JSON, thread safety)
- PCA9685 client updates (Vector3 -> /vector3_cmd, startup centering, 3rd servo)

Topics:
  Publishes  /cmd_vel                (Twist)        -> motor controller
  Publishes  /vector3_cmd            (Vector3)      -> PCA9685 servo node (CH0,1,2)
  Publishes  /manual_control_status  (String JSON)
  Subscribes /joy                    (sensor_msgs/Joy)
  Subscribes /emergency_stop         (Bool)

Parameters (with defaults):
  max_linear_velocity:    1.0   # m/s clamp
  max_angular_velocity:   2.0   # rad/s clamp
  command_timeout:        2.0   # s before auto-stop
  pan_sensitivity_deg:    2.0   # deg per joystick unit
  tilt_sensitivity_deg:   2.0
  third_axis_fixed_angle: 90.0  # used when no joystick 3rd axis mapped
"""

import time
import json
import threading

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSHistoryPolicy
from geometry_msgs.msg import Twist, Vector3
from std_msgs.msg import String, Bool
from sensor_msgs.msg import Joy


class ManualControlNode(Node):
    """Merged Manual Control Node for JABARI Rover (Vector3 servo output)."""

    def __init__(self):
        super().__init__('manual_control_node')

        # ------------------------------------------------------------
        # Parameters
        # ------------------------------------------------------------
        self.declare_parameter('max_linear_velocity', 1.0)
        self.declare_parameter('max_angular_velocity', 2.0)
        self.declare_parameter('command_timeout', 2.0)
        self.declare_parameter('pan_sensitivity_deg', 2.0)
        self.declare_parameter('tilt_sensitivity_deg', 2.0)
        self.declare_parameter('third_axis_fixed_angle', 90.0)

        self.max_linear_vel = float(self.get_parameter('max_linear_velocity').value)
        self.max_angular_vel = float(self.get_parameter('max_angular_velocity').value)
        self.command_timeout = float(self.get_parameter('command_timeout').value)
        self.pan_sensitivity_deg = float(self.get_parameter('pan_sensitivity_deg').value)
        self.tilt_sensitivity_deg = float(self.get_parameter('tilt_sensitivity_deg').value)
        self.third_axis_fixed_angle = float(self.get_parameter('third_axis_fixed_angle').value)

        # ------------------------------------------------------------
        # QoS Profiles
        # ------------------------------------------------------------
        reliable_qos = QoSProfile(
            reliability=QoSReliabilityPolicy.RELIABLE,
            history=QoSHistoryPolicy.KEEP_LAST,
            depth=10,
        )

        # ------------------------------------------------------------
        # Joystick mapping (adjust as needed)
        # ------------------------------------------------------------
        self.BUTTON_ENABLE = 9
        self.BUTTON_RESET_PAN_TILT = 8
        self.AXIS_LINEAR = 1
        self.AXIS_ANGULAR = 3
        self.AXIS_PAN = 5
        self.AXIS_TILT = 6
        # Optional 3rd servo axis: set to an integer index or None to use fixed param
        self.AXIS_THIRD = None

        # ------------------------------------------------------------
        # Servo state
        # ------------------------------------------------------------
        self.pan_angle = 90.0
        self.tilt_angle = 90.0
        self.third_axis_angle = float(self.third_axis_fixed_angle)

        # ------------------------------------------------------------
        # Publishers
        # ------------------------------------------------------------
        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', reliable_qos)
        self.vector3_cmd_pub = self.create_publisher(Vector3, '/vector3_cmd', reliable_qos)
        self.status_pub = self.create_publisher(String, '/manual_control_status', reliable_qos)

        # ------------------------------------------------------------
        # Subscribers
        # ------------------------------------------------------------
        self.joy_sub = self.create_subscription(Joy, '/joy', self.joy_callback, reliable_qos)
        self.emergency_stop_sub = self.create_subscription(Bool, '/emergency_stop',
                                                           self.emergency_stop_callback, reliable_qos)

        # ------------------------------------------------------------
        # Internal state
        # ------------------------------------------------------------
        self.joy_enabled = False
        self.last_button_states = []
        self.current_linear_vel = 0.0
        self.current_angular_vel = 0.0
        self.emergency_stop_active = False
        self.last_command_time = time.time()
        self.command_count = 0
        self.is_active = True
        self.command_lock = threading.Lock()

        # ------------------------------------------------------------
        # Timers
        # ------------------------------------------------------------
        self.status_timer = self.create_timer(2.0, self.publish_status)
        self.timeout_timer = self.create_timer(0.1, self.check_command_timeout)

        # ------------------------------------------------------------
        # Startup servo centering
        # ------------------------------------------------------------
        self.publish_vector3_servos(force=True)

        self.get_logger().info(
            'Manual Control Node initialized (Merged /vector3_cmd).\n'
            f'  - /cmd_vel clamp: lin {self.max_linear_vel} m/s, ang {self.max_angular_vel} rad/s\n'
            f'  - Servo topic: /vector3_cmd (x=pan, y=tilt, z=third)\n'
            f'  - 3rd channel mode: {"fixed_param" if self.AXIS_THIRD is None else "joystick"} '
            f'({self.third_axis_fixed_angle}째 if fixed)\n'
            f'  - Timeout: {self.command_timeout}s.'
        )

    # ==================================================================
    # Joystick callback
    # ==================================================================
    def joy_callback(self, msg: Joy):
        # Initialize button state tracking
        if not self.last_button_states:
            self.last_button_states = [0] * len(msg.buttons)

        # Edge-detect buttons
        for idx, (prev, curr) in enumerate(zip(self.last_button_states, msg.buttons)):
            if curr == 1 and prev == 0:
                if idx == self.BUTTON_ENABLE:
                    self.joy_enabled = not self.joy_enabled
                    state = 'ENABLED' if self.joy_enabled else 'DISABLED'
                    self.get_logger().info(f'Joystick control {state}')
                    if not self.joy_enabled:
                        self.send_stop_command()
                elif idx == self.BUTTON_RESET_PAN_TILT:
                    self.reset_servos()

        self.last_button_states = list(msg.buttons)

        # If enabled and safe, process movement + servos
        if self.joy_enabled and not self.emergency_stop_active:
            self.handle_movement(msg)
            self.handle_servos_from_joystick(msg)

    # ==================================================================
    # Movement
    # ==================================================================
    def handle_movement(self, msg: Joy):
        # Scale joystick [-1,1] to velocity limits
        linear_raw = -msg.axes[self.AXIS_LINEAR]
        angular_raw = msg.axes[self.AXIS_ANGULAR]

        linear = max(-self.max_linear_vel, min(self.max_linear_vel, linear_raw * self.max_linear_vel))
        angular = max(-self.max_angular_vel, min(self.max_angular_vel, angular_raw * self.max_angular_vel))

        twist = Twist()
        twist.linear.x = linear
        twist.angular.z = angular
        self.cmd_vel_pub.publish(twist)

        # Update state
        with self.command_lock:
            self.current_linear_vel = linear
            self.current_angular_vel = angular
            self.last_command_time = time.time()
            self.command_count += 1

        if abs(linear) > 0.1 or abs(angular) > 0.1:
            self.get_logger().info(f'Movement: lin={linear:.2f} ang={angular:.2f}')

    # ==================================================================
    # Servo handling
    # ==================================================================
    def handle_servos_from_joystick(self, msg: Joy):
        pan_input = msg.axes[self.AXIS_PAN] * self.pan_sensitivity_deg
        tilt_input = msg.axes[self.AXIS_TILT] * self.tilt_sensitivity_deg

        if self.AXIS_THIRD is not None and self.AXIS_THIRD < len(msg.axes):
            third_input = msg.axes[self.AXIS_THIRD] * self.tilt_sensitivity_deg
        else:
            third_input = 0.0

        updated = False
        if abs(pan_input) > 0.1:
            self.pan_angle = self._clamp_angle(self.pan_angle + pan_input)
            updated = True
        if abs(tilt_input) > 0.1:
            self.tilt_angle = self._clamp_angle(self.tilt_angle + tilt_input)
            updated = True
        if self.AXIS_THIRD is not None and abs(third_input) > 0.1:
            self.third_axis_angle = self._clamp_angle(self.third_axis_angle + third_input)
            updated = True

        if updated:
            self.publish_vector3_servos()

    def publish_vector3_servos(self, force: bool = False):
        # Use fixed param if 3rd axis unmapped
        z_angle = float(self.third_axis_fixed_angle) if self.AXIS_THIRD is None else self.third_axis_angle

        msg = Vector3()
        msg.x = self.pan_angle
        msg.y = self.tilt_angle
        msg.z = z_angle
        self.vector3_cmd_pub.publish(msg)

        if force or self.get_logger().get_effective_level() <= 20:  # INFO
            self.get_logger().info(
                f'Servo -> pan={msg.x:.1f}째 tilt={msg.y:.1f}째 third={msg.z:.1f}째'
            )

    def reset_servos(self):
        self.pan_angle = 90.0
        self.tilt_angle = 90.0
        if self.AXIS_THIRD is None:
            self.third_axis_angle = float(self.third_axis_fixed_angle)
        else:
            self.third_axis_angle = 90.0
        self.publish_vector3_servos(force=True)
        self.get_logger().info('Servos reset to center.')

    # ==================================================================
    # Safety
    # ==================================================================
    def send_stop_command(self):
        twist = Twist()
        twist.linear.x = 0.0
        twist.angular.z = 0.0
        self.cmd_vel_pub.publish(twist)
        with self.command_lock:
            self.current_linear_vel = 0.0
            self.current_angular_vel = 0.0
        self.get_logger().info('Stop command sent.')

    def emergency_stop_callback(self, msg: Bool):
        self.emergency_stop_active = msg.data
        if self.emergency_stop_active:
            self.get_logger().warn('EMERGENCY STOP ACTIVATED')
            self.send_stop_command()
            self.joy_enabled = False
        else:
            self.get_logger().info('Emergency stop cleared.')

    def check_command_timeout(self):
        current_time = time.time()
        with self.command_lock:
            time_since_last = current_time - self.last_command_time
            if (
                time_since_last > self.command_timeout
                and (self.current_linear_vel != 0.0 or self.current_angular_vel != 0.0)
            ):
                self.get_logger().warn(
                    f'Command timeout ({time_since_last:.1f}s) - stopping rover.'
                )
                self.send_stop_command()

    # ==================================================================
    # Status
    # ==================================================================
    def publish_status(self):
        try:
            with self.command_lock:
                status_data = {
                    'timestamp': time.time(),
                    'node_active': self.is_active,
                    'joystick_enabled': self.joy_enabled,
                    'emergency_stop_active': self.emergency_stop_active,
                    'movement': {
                        'linear_velocity': self.current_linear_vel,
                        'angular_velocity': self.current_angular_vel,
                        'time_since_last_command': time.time() - self.last_command_time,
                    },
                    'servos': {
                        'pan_angle': self.pan_angle,
                        'tilt_angle': self.tilt_angle,
                        'third_angle': (
                            self.third_axis_angle
                            if self.AXIS_THIRD is not None
                            else self.third_axis_fixed_angle
                        ),
                        'third_axis_mode': 'joystick' if self.AXIS_THIRD is not None else 'fixed_param',
                    },
                    'stats': {
                        'total_commands': self.command_count,
                        'max_linear_vel': self.max_linear_vel,
                        'max_angular_vel': self.max_angular_vel,
                    },
                }

            status_msg = String()
            status_msg.data = json.dumps(status_data)
            self.status_pub.publish(status_msg)
        except Exception as e:
            self.get_logger().error(f'Error publishing status: {e}')

    # ==================================================================
    # Shutdown
    # ==================================================================
    def shutdown_gracefully(self):
        self.get_logger().info('Shutting down Manual Control Node...')
        self.send_stop_command()
        self.reset_servos()
        self.is_active = False
        self.publish_status()
        self.get_logger().info('Manual Control Node shutdown complete.')

    # ==================================================================
    # Helpers
    # ==================================================================
    @staticmethod
    def _clamp_angle(angle: float) -> float:
        return max(0.0, min(180.0, angle))


def main(args=None):
    rclpy.init(args=args)
    node = None
    try:
        node = ManualControlNode()
        from rclpy.executors import MultiThreadedExecutor
        executor = MultiThreadedExecutor()
        executor.add_node(node)
        node.get_logger().info('Manual Control Node running...')
        executor.spin()
    except KeyboardInterrupt:
        if node is not None:
            node.get_logger().info('Keyboard interrupt.')
    except Exception as e:
        print(f'Error starting manual control node: {e}')
    finally:
        if node is not None:
            node.shutdown_gracefully()
            node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
